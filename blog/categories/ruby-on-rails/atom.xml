<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby on rails | Flavio Castelli]]></title>
  <link href="http://flavio.castelli.name/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://flavio.castelli.name/"/>
  <updated>2017-10-12T12:07:18+02:00</updated>
  <id>http://flavio.castelli.name/</id>
  <author>
    <name><![CDATA[Flavio Castelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing dister, a Heroku like solution for SUSE Studio]]></title>
    <link href="http://flavio.castelli.name/2011/03/29/introducing-dister-a-heroku-like-solution-for-suse-studio/"/>
    <updated>2011-03-29T15:39:21+02:00</updated>
    <id>http://flavio.castelli.name/2011/03/29/introducing-dister-a-heroku-like-solution-for-suse-studio</id>
    <content type="html"><![CDATA[<p><a href="http://susestudio.com">SUSE Studio</a> is  an awesome tool, with a couple of
clicks you can create an openSUSE/SUSE based system and deploy to your hard
drive, an usb flash,  a live dvd, a VMware/VirtualBox/Xen server and even
Amazon EC2 cloud.</p>

<p>Suppose you want to create a tailored SUSE Studio appliance to run a Ruby on
Rails app, this is a list of things you have to take care of:</p>

<ul>
<li>install all the gems required by the app (this can be a long list).</li>
<li>install and configure the database used by the app.</li>
<li>install and configure a webserver.</li>
<li>ensure all the required services are started at boot time.
You can save some time by cloning <a href="http://susegallery.com/a/CZ0T0D%0A/rails-in-a-box">this</a> appliance shared on <a href="http://susegallery.com/">SUSE Gallery</a>,
but this is still going to be boring.</li>
</ul>


<h2>Dister to the rescue!</h2>

<p>Dister is a command line tool similar to the one used by
<a href="http://heroku.com">Heroku</a> (one of the coolest ways to run your Rails app
into the cloud). Within a few steps you will be able to create a SUSE Studio
appliance running your rails application, download it and deploy wherever you
want.</p>

<p>Dister is named after SUSE Studio robot. It has been created by  <a href="http://opensuse.blip.tv/file/4678185/">Dominik
Mayer</a> and me during the latest
<a href="http://en.opensuse.org/Portal:Hackweek">hackweek</a>.</p>

<h2>How it works</h2>

<p>We are going to create a SUSE Studio appliance running a rails application
called <em>&ldquo;SUSE history&rdquo;</em>. The app uses <a href="http://gembundler.com/">bundler</a> to
handle its dependencies. This is its Gemfile file:</p>

<pre><code>﻿﻿source 'http://rubygems.org'
gem 'rails', '3.0.5'
gem 'pg'
gem "flutie", "~&gt; 1.1"
</code></pre>

<p>As you can see the app uses rails3, the
<a href="https://github.com/thoughtbot/flutie">flutie</a> gem and PostgreSQL as database.</p>

<h3>Appliance creation</h3>

<p>Move into the suse_history directory and execute the following command:</p>

<pre><code>dister create suse_history
</code></pre>

<p><img src="/images/introducing_dister/create.png"></p>

<p>As you can see dister has
already done a couple of things for you:</p>

<ul>
<li>created an appliance using latest version of openSUSE supported by SUSE Studio (you can use a different base system of course)</li>
<li>added the <em>devel:language:ruby:extensions</em> repository to the appliance: this repo contains tons of ruby packages (like <em>mod_passenger</em>)</li>
<li>installed a couple of things:

<ul>
<li><em>devel_C_C++</em> pattern: this will allow you to build native gems.</li>
<li><em>devel_ruby</em> pattern: provides ruby, rubygems and a couple of development packages needed to build native gems.</li>
<li><em>rubygem-bundler</em>: bundler is required by dister in order to handle the dependencies of your rails application.</li>
<li><em>rubygem-passenger-apache2</em>: dister uses <a href="http://www.modrails.com/">passenger</a> and apache2 to deploy your rails application.</li>
<li><em>postgresql-server</em>: dister noticed suse_history uses PostgreSQL as database, hence it automatically installs it.</li>
<li><em>rubygem-pg</em>: dister noticed suse_history uses PostgreSQL as database, hence it automatically installs the ruby&rsquo;s library forPostgreSQL.</li>
</ul>
</li>
<li>uploaded a custom build script which ensures:

<ul>
<li>mod_passenger module is loaded by Apache</li>
<li>both Apache and PostgreSQL are always started at boot time.</li>
<li>all dependencies are installed: this is done only during the first boot using bundler.</li>
<li>the database user required by your rails app is created. This is done only during the first boot using some SQL code.</li>
<li>the database used by the appliance is properly initialized (aka <em>rails db:create db:migrate</em>). This is done only during the first boot.</li>
</ul>
</li>
</ul>


<h3>Upload your code</h3>

<p>It&rsquo;s time to upload suse_history code. This is done using the following
command:</p>

<pre><code>dister push
</code></pre>

<p><img src="/images/introducing_dister/push.png"></p>

<p>As you can see dister packaged the
application source code and all its dependencies into a single archive. Then
uploaded the archive to SUSE Studio as an overlay file. Dister uploaded also
the configuration files required by Apache and by PostgreSQL setup.</p>

<h3>Build your appliance</h3>

<p>It&rsquo;s build time!</p>

<pre><code>dister build
</code></pre>

<p><img src="/images/introducing_dister/build.png">
The appliance has automatically being built
using the <em>raw disk</em>. You can use different formats of course.</p>

<h3>Testdrive</h3>

<p>Testdrive is one of the coolest features of SUSE Studio. Unfortunately dister
doesn&rsquo;t support it yet. Just visit your appliance page and start testdrive
from your browser. Just enable testdrive networking and connect to your
appliance:</p>

<p><img src="/images/introducing_dister/testdrive.png"></p>

<h3>Download</h3>

<p>Your appliance is working flawlessly. Download it and deploy it wherever you
want.</p>

<pre><code>dister download
</code></pre>

<h2>Current status</h2>

<p>As you can see dister handles pretty fine a simple Rails application, but
there&rsquo;s still room for improvements.</p>

<p>Here&rsquo;s a small list of the things on my TODO list:</p>

<ul>
<li>The dependency management should install gems using rpm packages. This would make the installation of native gems easier, right now the user has to manually add all the development libraries required by the gem. Moreover it would reduce the size of the overlay files uploaded to SUSE Studio.</li>
<li>SUSE Studio Testdrive should be supported.</li>
<li>It should be possible to deploy the SUSE Studio directly to EC2.</li>
<li>Fix bugs!</li>
</ul>


<p>Bugs and enhancements are going to be tracked
<a href="https://github.com/flavio/dister/issues">here</a>.</p>

<h2>Contribute</h2>

<p>Dister code can be found here on <a href="https://github.com/flavio/dister">github</a>,
fork it and start contributing.</p>

<p>If you are a student you can work on dister during the next <a href="http://en.opensuse.org/openSUSE:GSOC_2011_Ideas#Heroku_like_solution_for%0A_SUSE_Studio">Google Summer of
code</a>, apply now!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to run a single rails unit test]]></title>
    <link href="http://flavio.castelli.name/2010/05/28/rails_execute_single_test/"/>
    <updated>2010-05-28T15:57:57+02:00</updated>
    <id>http://flavio.castelli.name/2010/05/28/rails_execute_single_test</id>
    <content type="html"><![CDATA[<p>This post explains how to execute a single unit test (or even a single test
method) instead of running the complete unit test suite.</p>

<p>In order to run the unit tests of your rails application, basically you have
these official possibilities:</p>

<ul>
<li><code>rake test</code>: runs all unit, functional and integration tests.</li>
<li><code>rake test:units</code>: runs all the unit tests.</li>
<li><code>rake test:functionals</code>: runs all the functional tests.</li>
<li><code>rake test:integration</code>: runs all the integration tests.
Each one of these commands requires some time and they are not the best
solution while developing a new feature or fixing a bug. In this circumstance
we just want to have a quick feedback from the unit test of the code we are
editing.</li>
</ul>


<p>Waiting for all the unit/functional tests to complete decreases our
productivity, what we need is to execute just a single unit test. Fortunately
there are different solutions for this problem, let&rsquo;s go through them.</p>

<h2>The easy approach: use your favorite IDE</h2>

<p>Most of the IDE supporting ruby allow you to run a single unit test. If you
are using Netbeans running a single unit test is really easy:</p>

<ul>
<li>make sure the editor if showing the file you want to test or the file containing its unit tests</li>
<li>Hit <em>Ctrl+Shift+F6</em> or click on the following menu entry: <em>Debug->Debug Test File</em>
Two new windows will be opened: one will contain the output produced by your
unit test, the other one will show the results of the unit test.</li>
</ul>


<p>As you will notice the summary window contains also some useful information
like the:</p>

<ul>
<li>hyper links to the exact location of the code that produced the error/failure.</li>
<li>execution time required by each one of the test methods.
As you will experience it will be like &ldquo;compiling&rdquo; your ruby code.</li>
</ul>


<h2>From the console</h2>

<p>If you are not using Netbeans you can always rely on some command line tools.</p>

<h3>No additional tools</h3>

<p>These &ldquo;tricks&rdquo; don&rsquo;t require additional gems, hence they will work out of the
box.</p>

<p>The first solution is to call this rake task:</p>

<pre><code>rake test TEST=path_to_test_file
</code></pre>

<p>So the final command should look like</p>

<pre><code>rake test TEST=test/unit/invitation_test.rb
</code></pre>

<p>Unfortunately on my machine this command repeats the same test three times, I
hope you won&rsquo;t have the same weird behavior also on your systems&hellip;</p>

<p>Alternatively you can use the following command:</p>

<pre><code>ruby -I"lib:test" path_to_test_file"
</code></pre>

<p>It&rsquo;s even possible to <strong>call a specific test method of your testcase</strong>:</p>

<pre><code>ruby -I"lib:test" path_to_test_file -n name_of_the_method"
</code></pre>

<p>So calling:</p>

<pre><code>ruby -I"lib:test" test/unit/invitation_test.rb - test_should_create_invitation
</code></pre>

<p>will execute <strong>only</strong> <em>InvitationTest::test_should_create_invitation</em>.</p>

<p>It&rsquo;s also possible to <strong>execute only the test methods matching a regular
expression</strong>. Look at this example:</p>

<pre><code>ruby -I"lib:test" test/unit/invitation_test.rb -n /.*between.*/
</code></pre>

<p>This command will execute only the test methods matching the <em>/.<em>between.</em>/</em>
regexp.</p>

<h3>Using the single_test gem</h3>

<p>If you want to avoid the awful syntax showed in the previous paragraph there&rsquo;s
a gem that can help you, it&rsquo;s called
<a href="http://github.com/grosser/single_test">single_test</a>.</p>

<p>The github page contains a nice documentation, but let&rsquo;s go through the most
common use cases.</p>

<p>You can install the gem as a rails plugin:</p>

<pre><code>script/plugin install git://github.com/grosser/single_test.git
</code></pre>

<p>single_test will add new rake tasks to your rails project, but <strong>won&rsquo;t</strong>
override the original ones.</p>

<p>Suppose we want to execute the unit test of <em>user.rb</em>, just type the following
command:</p>

<pre><code>rake test:user
</code></pre>

<p>If you want to execute the functional test of <em>User</em> just call:</p>

<pre><code>rake test:user_c
</code></pre>

<p>Appending <em>&ldquo;</em>c&rdquo;_ to the class name will automatically execute its functional
test (if it exists).</p>

<p>It&rsquo;s still possible to <strong>execute a specif test method</strong>:</p>

<pre><code>rake test:user_c:_test_name_
</code></pre>

<p>So calling:</p>

<pre><code>rake test:user_c:test_update_user
</code></pre>

<p>Will execute the <em>test_update_user</em> method written inside of
<em>test/functional/user_controller_test.rb</em>.</p>

<p>It&rsquo;s still possible to use regexp:</p>

<pre><code>rake test:invitation:.*between.*
</code></pre>

<p>This syntax is equivalent to <code>ruby -I"lib:test" test/unit/invitation_test.rb
-n /.*between.*/</code>.</p>

<h2>Possible issues</h2>

<p>When a single unit test is run all the usual database initialization tasks are
not performed. If your code is relying on newly created migrations you will
surely have lots of errors. This is happening because the new migrations have
not been applied to the test database.</p>

<p>In order to fix these errors just execute:</p>

<pre><code>rake db:test:prepare
</code></pre>

<p>before running your unit test.</p>
]]></content>
  </entry>
  
</feed>
