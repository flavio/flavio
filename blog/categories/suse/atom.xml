<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: suse | Flavio Castelli]]></title>
  <link href="http://flavio.castelli.name/blog/categories/suse/atom.xml" rel="self"/>
  <link href="http://flavio.castelli.name/"/>
  <updated>2015-07-24T14:39:44+02:00</updated>
  <id>http://flavio.castelli.name/</id>
  <author>
    <name><![CDATA[Flavio Castelli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introducing Portus: an authorization service and front-end for Docker registry]]></title>
    <link href="http://flavio.castelli.name/2015/04/23/introducing-portus-a-user-interface-for-docker-registry/"/>
    <updated>2015-04-23T21:43:09+02:00</updated>
    <id>http://flavio.castelli.name/2015/04/23/introducing-portus-a-user-interface-for-docker-registry</id>
    <content type="html"><![CDATA[<p>One of the perks of working at SUSE is hackweek, an entire week you can dedicate
working on whatever project you want. Last week the 12th edition of hackweek
took place. So I decided to spend it working on solving one of the problems many
users have when running an on-premise instance of a Docker registry.</p>

<p>The Docker registry works like a charm, but it&rsquo;s hard to have full
control over the images you push to it. Also there&rsquo;s no web interface
that can provide a quick overview of registry&rsquo;s contents.</p>

<p>So <a href="https://twitter.com/skullzeek">Artem</a>, <a href="https://twitter.com/eotchi">Federica</a>
and I created the <a href="https://github.com/SUSE/Portus">Portus project</a> (BTW
<em>&ldquo;portus&rdquo;</em> is the Latin name for harbour).</p>

<h2>Portus as an authorization service</h2>

<p>The first goal of Portus is to allow users to have a better control over the
contents of their private registries. It makes possible to write policies
like:</p>

<ul>
<li>everybody can push and pull images to a certain namespace,</li>
<li>everybody can pull images from a certain namespace but only certain users can
push images to it,</li>
<li>only certain users can pull and push to a certain namespace; making all the
images inside of it invisible to unauthorzied users.</li>
</ul>


<p>This is done implementing the
<a href="https://github.com/docker/distribution/blob/master/docs/spec/auth/token.md">token based authentication system</a>
supported by the <a href="https://github.com/docker/distribution">latest version</a> of the
Docker registry.</p>

<h3>Docker login and Portus authentication in action</h3>

<script type="text/javascript" src="https://asciinema.org/a/19171.js" id="asciicast-19171" async></script>


<h2>Portus as a front-end for Docker registry</h2>

<p>Portus listens to the <a href="https://github.com/docker/distribution/blob/master/docs/notifications.md">notifications</a>
sent by the Docker registry and uses them to populate its own database.</p>

<p>Using this data Portus can be used to navigate through all the namespaces and
the repositories that have been pushed to the registry.</p>

<p><a href="/images/portus/repositories.png"><img src="/images/portus/repositories.png" alt="repositories view" /></a></p>

<p>We also worked on a client library that can be used to fetch extra
information from the registry (i.e. repositories&#8217; manifests) to extend Portus&#8217;
knowledge.</p>

<h2>The current status of development</h2>

<p>Right now Portus has just the concept of users. When you sign up into Portus a
private namespace with your username will be created. You are the only one with
push and pull rights over it; nobody else will be able to mess with it.
Also pushing and pulling to the &ldquo;global&rdquo; namespace is currently not allowed.</p>

<p>The user interface is still a work in progress. Right now you can browse all
the namespaces and the repositories available on your registry. However user&rsquo;s
permissions are not taken into account while doing that.</p>

<p>If you want to play with Portus you can use the development environment managed
by Vagrant. In the near future we are going to publish a Portus appliance and
obviously a Docker image.</p>

<p>Please keep in mind that Portus is just the result of one week of work. A lot of
things are missing but the foundations are solid.</p>

<p>Portus can be found on <a href="https://github.com/SUSE/Portus">this repository</a> on
GitHub. Contributions (not only code, also proposals, bugs,&hellip;) are welcome!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building docker images with KIWI]]></title>
    <link href="http://flavio.castelli.name/2014/05/06/building-docker-containers-with-kiwi/"/>
    <updated>2014-05-06T22:20:00+02:00</updated>
    <id>http://flavio.castelli.name/2014/05/06/building-docker-containers-with-kiwi</id>
    <content type="html"><![CDATA[<p>I&rsquo;m pleased to announce <a href="https://github.com/schaefi">Marcus Sch√§fer</a> has
just made possible to build docker images with <a href="http://opensuse.github.io/kiwi/">KIWI</a>.</p>

<p>For those who never heard about it, KIWI is a tool which creates Linux systems
for both physical and virtual machines. It can create openSUSE, SUSE and other types of
Linux distributions.</p>

<p><strong>Update:</strong> I changed the required version of kiwi and the openSUSE 13.1 template.
Kiwi just received some improvements which do no longer force the image
to include the <em>lxc</em> package.</p>

<h2>Why is this important?</h2>

<p>As you might know Docker has already its <a href="http://docs.docker.io/reference/builder/">build system</a>
which provides a really easy way to create new images. However these images
must be based on existing ones, which leads to the problem of creating the 1st
parent image. That&rsquo;s where KIWI comes to the rescue.</p>

<p>Indeed Kiwi can be used to build the openSUSE/SUSE/whatever docker images that are
going to act as the foundation blocks of other ones.</p>

<h2>Requirements</h2>

<p>Docker support has been added to KIWI 5.06.87. You can find this package inside
of the <a href="https://build.opensuse.org/project/show?project=Virtualization%3AAppliances">Virtualization:Appliances</a>
project on OBS.</p>

<p>Install the <code>kiwi</code> and the <code>kiwi-doc</code> packages on your system. Then go to the
<code>/usr/share/doc/packages/kiwi/examples/</code> directory where you will find a simple
openSUSE 13.1 template.</p>

<h2>Building the system</h2>

<p>Just copy the whole <code>/usr/share/doc/packages/kiwi/examples/suse-13.1/suse-docker-container</code>
directory to another location and make your changes.</p>

<p>The heart of the whole image is the <code>config.xml</code> file:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;image schemaversion="6.1" name="suse-13.1-docker-guest"&gt;
  &lt;description type="system"&gt;
    &lt;author&gt;Flavio Castelli&lt;/author&gt;
    &lt;contact&gt;fcastelli@suse.com&lt;/contact&gt;
    &lt;specification&gt;openSUSE 13.1 docker image&lt;/specification&gt;
  &lt;/description&gt;
  &lt;preferences&gt;
    &lt;type image="docker" container="os131"&gt;
      &lt;machine&gt;
        &lt;vmdisk/&gt;
        &lt;vmnic interface="eth0" mode="veth"/&gt;
      &lt;/machine&gt;
    &lt;/type&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;packagemanager&gt;zypper&lt;/packagemanager&gt;
    &lt;rpm-check-signatures&gt;false&lt;/rpm-check-signatures&gt;
    &lt;rpm-force&gt;true&lt;/rpm-force&gt;
    &lt;locale&gt;en_US&lt;/locale&gt;
    &lt;keytable&gt;us.map.gz&lt;/keytable&gt;
    &lt;hwclock&gt;utc&lt;/hwclock&gt;
    &lt;timezone&gt;US/Eastern&lt;/timezone&gt;
  &lt;/preferences&gt;
  &lt;users group="root"&gt;
    &lt;user password="$1$wYJUgpM5$RXMMeASDc035eX.NbYWFl0" home="/root" name="root"/&gt;
  &lt;/users&gt;
  &lt;repository type="yast2"&gt;
    &lt;source path="opensuse://13.1/repo/oss/"/&gt;
  &lt;/repository&gt;
  &lt;packages type="image"&gt;
    &lt;package name="coreutils"/&gt;
    &lt;package name="iputils"/&gt;
  &lt;/packages&gt;
  &lt;packages type="bootstrap"&gt;
    &lt;package name="filesystem"/&gt;
    &lt;package name="glibc-locale"/&gt;
    &lt;package name="module-init-tools"/&gt;
  &lt;/packages&gt;
&lt;/image&gt;
</code></pre>

<p>This is a really minimal image which contains just a bunch of packages.</p>

<p>The first step is the creation of the image&rsquo;s root system:</p>

<pre><code>kiwi -p /usr/share/doc/packages/kiwi/examples/suse-13.1/suse-docker-container \
     --root /tmp/myimage
</code></pre>

<p>The next step compresses the file system of the image into a single tarball:</p>

<pre><code>    kiwi --create /tmp/myimage --type docker -d /tmp/myimage-result
</code></pre>

<p>The tarball can be found under <code>/tmp/myimage-result</code>. This can be imported
into docker using the following command:</p>

<pre><code>docker import - myImage &lt; /path/to/myimage.tbz
</code></pre>

<p>The image named <code>myImage</code> is now ready to be used.</p>

<h2>What&rsquo;s next</h2>

<p>In the next days I&rsquo;ll make another blog post explaining how to build docker
images using KIWI and the <a href="http://openbuildservice.org/">Open Build Service</a>.
This is a powerful combination which allows to achieve continuous delivery.</p>

<p>Stay tuned and have fun!</p>
]]></content>
  </entry>
  
</feed>
