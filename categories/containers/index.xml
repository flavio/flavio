<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Containers on Flavio Castelli</title>
    <link>http://flavio.castelli.me/categories/containers/</link>
    <description>Recent content in Containers on Flavio Castelli</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Oct 2020 18:30:00 +0200</lastBuildDate>
    
	<atom:link href="http://flavio.castelli.me/categories/containers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Build multi-architecture container images using argo workflow</title>
      <link>http://flavio.castelli.me/2020/10/05/build-multi-architecture-container-images-using-argo-workflow/</link>
      <pubDate>Mon, 05 Oct 2020 18:30:00 +0200</pubDate>
      
      <guid>http://flavio.castelli.me/2020/10/05/build-multi-architecture-container-images-using-argo-workflow/</guid>
      <description>Note well: this blog post is part of a series, checkout the previous episode about running containerized buildah on top of Kubernetes.
 Quick recap I have a small Kubernetes cluster running at home that is made of ARM64 and x86_64 nodes. I want to build multi-architecture images so that I can run them everywhere on the cluster, regardless of the node architecture. My plan is to leverage the same cluster to build these container images.</description>
    </item>
    
    <item>
      <title>Build multi-architecture container images using Kubernetes</title>
      <link>http://flavio.castelli.me/2020/09/16/build-multi-architecture-container-images-using-kubernetes/</link>
      <pubDate>Wed, 16 Sep 2020 10:00:00 +0200</pubDate>
      
      <guid>http://flavio.castelli.me/2020/09/16/build-multi-architecture-container-images-using-kubernetes/</guid>
      <description>Recently I&amp;rsquo;ve added some Raspberry Pi 4 nodes to the Kubernetes cluster I&amp;rsquo;m running at home.
The overall support of ARM inside of the container ecosystem improved a lot over the last years with more container images made available for the armv7 and the arm64 architectures.
But what about my own container images? I&amp;rsquo;m running some homemade containerized applications on top of this cluster and I would like to have them scheduled both on the x64_64 nodes and on the ARM ones.</description>
    </item>
    
    <item>
      <title>Semantic versioning and containers</title>
      <link>http://flavio.castelli.me/2020/02/27/semantic-versioning-and-containers/</link>
      <pubDate>Thu, 27 Feb 2020 21:48:16 +0200</pubDate>
      
      <guid>http://flavio.castelli.me/2020/02/27/semantic-versioning-and-containers/</guid>
      <description>Developers are used to express the dependencies of their programs using semantic versioning constraints.
For example a Node.js application relying on left-pad could force only certain versions of this library to be used by specifying a constraint like &amp;gt;= 1.1.0 &amp;lt; 1.2.0. This would force npm to install the latest version of the library that satisfies the constraint.
How does that translates to containers?
Imagine the following scenario: a developer deploys a containerized application that requires a Redi database.</description>
    </item>
    
    <item>
      <title>Hackweek Project Docker Registry Mirror</title>
      <link>http://flavio.castelli.me/2018/07/18/hackweek-project-docker-registry-mirror/</link>
      <pubDate>Wed, 18 Jul 2018 15:48:16 +0200</pubDate>
      
      <guid>http://flavio.castelli.me/2018/07/18/hackweek-project-docker-registry-mirror/</guid>
      <description>As part of SUSE Hackweek 17 I decided to work on a fully fledged docker registry mirror.
You might wonder why this is needed, after all it&amp;rsquo;s already possible to run a docker distribution (aka registry) instance as a pull-through cache. While that&amp;rsquo;s true, this solution doesn&amp;rsquo;t address the needs of more &amp;ldquo;sophisticated&amp;rdquo; users.
The problem Based on the feedback we got from a lot of SUSE customers it&amp;rsquo;s clear that a simple registry configured to act as a pull-through cache isn&amp;rsquo;t enough.</description>
    </item>
    
  </channel>
</rss>